{"ast":null,"code":"export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? `Choose date, selected date is ${utils.format(utils.date(rawValue), 'fullDate')}` : 'Choose date';\n}\nexport const getDisplayDate = (utils, rawValue, inputFormat) => {\n  const date = utils.date(rawValue);\n  const isEmpty = rawValue === null;\n  if (isEmpty) {\n    return '';\n  }\n  return utils.isValid(date) ? utils.formatByString(\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    const defaultWarning = [`The mask \"${mask}\" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`];\n    if (format.includes('MMM')) {\n      console.warn([...defaultWarning, `Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`].join('\\n'));\n    } else if (inferredFormatPatternWith2Digits !== mask && inferredFormatPatternWith1Digits === mask) {\n      console.warn([...defaultWarning, `Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`].join('\\n'));\n    } else {\n      console.warn(defaultWarning.join('\\n'));\n    }\n  }\n  return isMaskValid;\n}\nexport const maskedDateFormatter = (mask, acceptRegexp) => value => {\n  let outputCharIndex = 0;\n  return value.split('').map((char, inputCharIndex) => {\n    acceptRegexp.lastIndex = 0;\n    if (outputCharIndex > mask.length - 1) {\n      return '';\n    }\n    const maskChar = mask[outputCharIndex];\n    const nextMaskChar = mask[outputCharIndex + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n    outputCharIndex += formattedChar.length;\n    const isLastCharacter = inputCharIndex === value.length - 1;\n    if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n    return formattedChar;\n  }).join('');\n};","map":{"version":3,"names":["getTextFieldAriaText","rawValue","utils","isValid","date","format","getDisplayDate","inputFormat","isEmpty","formatByString","MASK_USER_INPUT_SYMBOL","staticDateWith2DigitTokens","staticDateWith1DigitTokens","checkMaskIsValidForCurrentFormat","mask","acceptRegex","formattedDateWith1Digit","inferredFormatPatternWith1Digits","replace","inferredFormatPatternWith2Digits","isMaskValid","lib","process","env","NODE_ENV","defaultWarning","includes","console","warn","join","maskedDateFormatter","acceptRegexp","value","outputCharIndex","split","map","char","inputCharIndex","lastIndex","length","maskChar","nextMaskChar","acceptedChar","test","formattedChar","isLastCharacter"],"sources":["C:/Users/sasan/todo-page/node_modules/@mui/x-date-pickers/internals/utils/text-field-helper.js"],"sourcesContent":["export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? `Choose date, selected date is ${utils.format(utils.date(rawValue), 'fullDate')}` : 'Choose date';\n}\nexport const getDisplayDate = (utils, rawValue, inputFormat) => {\n  const date = utils.date(rawValue);\n  const isEmpty = rawValue === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    const defaultWarning = [`The mask \"${mask}\" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`];\n\n    if (format.includes('MMM')) {\n      console.warn([...defaultWarning, `Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`].join('\\n'));\n    } else if (inferredFormatPatternWith2Digits !== mask && inferredFormatPatternWith1Digits === mask) {\n      console.warn([...defaultWarning, `Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`].join('\\n'));\n    } else {\n      console.warn(defaultWarning.join('\\n'));\n    }\n  }\n\n  return isMaskValid;\n}\nexport const maskedDateFormatter = (mask, acceptRegexp) => value => {\n  let outputCharIndex = 0;\n  return value.split('').map((char, inputCharIndex) => {\n    acceptRegexp.lastIndex = 0;\n\n    if (outputCharIndex > mask.length - 1) {\n      return '';\n    }\n\n    const maskChar = mask[outputCharIndex];\n    const nextMaskChar = mask[outputCharIndex + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n    outputCharIndex += formattedChar.length;\n    const isLastCharacter = inputCharIndex === value.length - 1;\n\n    if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n\n    return formattedChar;\n  }).join('');\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}